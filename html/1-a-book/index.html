<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>1-a-book</title>
    <style>
    body {
      margin: 0;
      overflow: hidden;
    }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/hammer.js/2.0.8/hammer.min.js"></script>
  </head>
  <body>
    <script>
    const angleToRadian = angle => angle * (Math.PI / 180)
    const radianToAngle = radian => radian * (180 / Math.PI)
    </script>
    <script>
    const init = async () => {
      let isAnimating = true
      const background = '#ededed'

      // 创建场景
      const scene = new THREE.Scene()
      scene.background = new THREE.Color(background)

      // 创建立方体
      const geometry = new THREE.BoxGeometry(9, 16, 1)

      // 加载材质、加载纹理
      const materials = [
        new THREE.MeshBasicMaterial({ color: background }),
        new THREE.MeshBasicMaterial({ color: background }),
        new THREE.MeshBasicMaterial({ color: background }),
        new THREE.MeshBasicMaterial({ color: background }),
        new THREE.MeshBasicMaterial({ color: background }),
        new THREE.MeshBasicMaterial({ color: background })
      ]
      const textures = ['right.jpg', 'left.jpg', 'up.jpg', 'down.jpg', 'front.jpg', 'back.jpg']
      textures.forEach((texturePath, textureIndex) => new THREE.TextureLoader().load(texturePath, texture => (materials[textureIndex] = new THREE.MeshBasicMaterial({ map: texture }))))

      // 创建网格并添加到场景
      const cube = new THREE.Mesh(geometry, materials)
      scene.add(cube)

      // 创建相机
      const camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      )
      camera.position.z = 30

      // 创建渲染器
      const renderer = new THREE.WebGLRenderer({
        antialias: true // 抗锯齿
      })
      renderer.setSize(window.innerWidth, window.innerHeight)
      document.body.appendChild(renderer.domElement)

      // 动画循环
      const animate = () => {
        if (!isAnimating) return
        requestAnimationFrame(animate)

        // 旋转立方体（弧度）
        // cube.rotation.x += 0.01
        cube.rotation.y -= 0.01

        // 渲染场景
        renderer.render(scene, camera)
      }
      animate()

      // 监听拖动手势
      const hammer = new Hammer(document.body)
      hammer.get('pan').set({ direction: Hammer.DIRECTION_ALL })
      hammer.on('panstart', () => {
        isAnimating = false
      })
      hammer.on('panend', () => {
        isAnimating = true
        animate()
      })
      hammer.on('pan', (event) => {
        // console.log('event：', event)
        const deltaX = event.velocityX * 0.1 // 水平拖动
        const deltaY = event.velocityY * 0.1 // 垂直拖动

        cube.rotation.y += deltaX
        cube.rotation.x += deltaY

        renderer.render(scene, camera)
      })
    }
    init()
    </script>
  </body>
</html>
